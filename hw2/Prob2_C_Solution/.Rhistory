}
arr1 <- rbind(c(1,6),
c(2,1),
c(3,3),
c(1,2),
c(1,3),
c(2,4),
c(4,2),
c(3,1),
c(6,3))
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
for (row in 1:rows) {
print(edges[row,])
}
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
arr1 <- rbind(c(1,6),
c(2,1),
c(3,3),
c(1,2),
c(1,3),
c(2,4),
c(4,2),
c(3,1),
c(6,3))
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
print(edges[rows,])
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
print(edges[rows,] * 10)
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
print(edges[,rows])
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
print(edges[rows,])
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
arr1
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
print(edges[rows,1])
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
print(edges[rows,1])
print(edges[rows,2])
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
print(edges[rows,1] + edges[rows,2])
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
# print(edges[rows,1] + edges[rows,2])
for (r in rows) {
print(r)
}
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
# print(edges[rows,1] + edges[rows,2])
for (r in 1:length(rows)) {
print(rows[r])
}
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
cl <- makeSOCKcluster(rep("localhost", 2))
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
# print(edges[rows,1] + edges[rows,2])
if(edges[rows,1] != edges[rows,2]) {
print(edges[rows,1])
}
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
# print(edges[rows,1] + edges[rows,2])
if(edges[rows,1] != edges[rows,2]) {
print(edges[rows,1])
} else  {
print(0)
}
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
# print(edges[rows,1] + edges[rows,2])
print(edges[rows,])
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
arr1 <- rbind(c(6,6),
c(2,1),
c(3,3),
c(1,2),
c(1,3),
c(2,4),
c(4,2),
c(3,1),
c(6,3))
on.exit(stopCluster(c2))
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
# print(edges[rows,1] + edges[rows,2])
print(edges[rows,])
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
}
}
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
# print(edges[rows,1] + edges[rows,2])
print(edges[rows,])
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
print(edges[rows,])
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
}
hw1R(arr1)
hw1R <- function(edges) {
cl <- makeSOCKcluster(rep("localhost", 2))
rowgrps = splitIndices(nrow(edges), length(cl))
findMatch <- function(rows) {
print(edges[rows,2])
}
out <- clusterApply(cl, rowgrps, findMatch)
Reduce(c, out)
}
hw1R(arr1)
library(snow)
data =  read.table("../data/twitter_combined.txt", sep = " ")
setwd("/Users/asoong/desktop/ecs/ecs158/Parallel-Processing/R_solution/src")
data =  read.table("../data/twitter_combined.txt", sep = " ")
data = data.matrix(data)
recippar <- function (data) {
# sort the rows based on the first column
data = data[order(data[,1]),]
# get the number of reflexive rows
reflexive_num = sum(data[,1]==data[,2])
# create virtual clusters
cls <- makeSOCKcluster(rep("localhost",6))
# parallel part
par_search = function(cls,data) {
rowgrps <- splitIndices(nrow(data), length(cls))
N = nrow(data)
col1= unlist(data[,1])
# a helper function for binary search
bin_search <- function( arr, l, r, x){
if (r>=l) {
mid = l+(r-l)%/%2
if(arr[mid] == x) return(mid)
if (arr[mid] > x)
return(bin_search(arr, l, mid-1, x))
return(bin_search(arr, mid+1,r,x))
}
return(-1)
}
# the work function search a groups rows for reciprocal eges in all the rows
# when searching, the second node is seared by binary_search first and
# then a local bidrectional search is conducted.
grpsearch  <- function(grp) {
score = 0
for (i in grp)
{
row = unlist(data[i,])
index = bin_search(col1,1,N,row[2])
if (index!=-1) {
found = FALSE
i = index
while (col1[i] == row[2] && i > 0) {
if (data[i,2] == row[1]) {
score = score +1
found = TRUE
break
}
i = i-1
}
if (!found) {
i=index+1
while (col1[i] == row[2] && i <=N) {
if (data[i,2] == row[1]) {
score = score +1
break
}
i = i+1
}
}
}
}
return(score)
}
# apply the work functions on the split rows
mout <- clusterApply(cls, rowgrps, grpsearch)
Reduce(c, mout)
}
ptm<-proc.time()
scores = par_search(cls,data)
print(proc.time() - ptm)
res = (sum(scores)-reflexive_num)/2
return(res)
}
res = recippar(data)
library(Rdsm)
install.packages("Rdsm")
library(Rdsm)
A = matrix(1:10, 2, 5)
foo = function() {
}
foo = function() {
print(A)
}
foo
foo()
foo = function() {
print(A)
}
foo()
library(zoo)
install.packages("zoo")
library(zoo)
arr = c(1,2,3,4,5)
getidxs(arr)
arr = matrix(1:10, 1, 10)
arr
arr = matrix(1:10, 10, 1)
arr
getidxs(arr)
getidxs(10-2+1)
maxburst <- function(x, k, mas, rslts) {
require(Rdsm)
require(zoo)
n <- length(x)
myidxs <- getidxs(n - k + 1)
myfirst <- myidxs[1]
mylast <- myidxs[length(myidxs)]
mas[1, myfirst:mylast] <- rollmean(x[myfirst:(mylast + k - 1)], k)
barr()
if (myinfo$id == 1) {
rslts[1,1] <- which.max(mas[,])
rslts[1,2] <- mas[1, rslts[1, 1]]
}
}
maxburst <- function(x, k, mas, rslts) {
require(Rdsm)
require(zoo)
n <- length(x)
myidxs <- getidxs(n - k + 1)
myfirst <- myidxs[1]
mylast <- myidxs[length(myidxs)]
mas[1, myfirst:mylast] <- rollmean(x[myfirst:(mylast + k - 1)], k)
barr()
if (myinfo$id == 1) {
rslts[1,1] <- which.max(mas[,])
rslts[1,2] <- mas[1, rslts[1, 1]]
}
}
clusterExport()
test <- function(cls) {
require(Rdsm)
mgrinit(cls)
mgrmakevar(cls, "mas", 1, 9)
mgrmakevar(cls, "rslts", 1, 2)
x <<- c(5,7,6,20,4,14,11,12,15,17)
clusterExport(cls, "maxburst")
clusterExport(cls, "x")
clusterEvalQ(cls, maxburst(x, 2, mas, rslts))
print(rslts[,])
}
print(A[,])
print(A)
test()
cls <- makeSOCKcluster(rep("localhost",6))
cls <- makeSOCKcluster(rep("localhost",2))
test(cls)
test <- function(cls) {
require(Rdsm)
mgrinit(cls)
mgrmakevar(cls, "mas", 1, 9)
mgrmakevar(cls, "rslts", 1, 2)
print(mas)
x <<- c(5,7,6,20,4,14,11,12,15,17)
clusterExport(cls, "maxburst")
clusterExport(cls, "x")
clusterEvalQ(cls, maxburst(x, 2, mas, rslts))
print(rslts[,])
}
cls <- makeSOCKcluster(rep("localhost",2))
test(cls)
test <- function(cls) {
require(Rdsm)
mgrinit(cls)
mgrmakevar(cls, "mas", 1, 9)
mgrmakevar(cls, "rslts", 1, 2)
x <<- c(5,7,6,20,4,14,11,12,15,17)
clusterExport(cls, "maxburst")
clusterExport(cls, "x")
clusterEvalQ(cls, maxburst(x, 2, mas, rslts))
print(rslts[,])
}
cls <- makeSOCKcluster(rep("localhost",2))
test(cls)
test(cls)
on.exit(stopCluster(cls))
source('~/.active-rstudio-document')
A = matrix(1:100, 10,10)
A
library(snow)
cls <- makeSOCKcluster(rep("localhost",2))
rowgrps = splitIndices(nrow(A), length(cls))
rowgrps
foo <- function (data) {
cls <- makeSOCKcluster(rep("localhost",2))
rowgrps <- splitIndices(nrow(data), length(cls))
addOne <- function(grp) {
data[grp,] = data[grp,] + 1
}
clusterApply(cls, rowgrps, addOne)
}
foo(A)
foo <- function (data) {
cls <- makeSOCKcluster(rep("localhost",2))
rowgrps <- splitIndices(nrow(data), length(cls))
addOne <- function(grp) {
data[grp,] = data[grp,] + 1
}
clusterApply(cls, rowgrps, addOne)
}
foo(A)
library(snow)
cls <- makeCluster(2)
arr1 = c(5,12,3,9,11,22,6)
findMax(cls, array) {
}
library(snow)
cls <- makeCluster(2)
arr1 = c(5,12,3,9,11,22,6)
findMax(cls, array) {
rowgrps <- splitIndices(length(array), length(cls))
helper <- function(group) {
return max(array[grou])
}
out <- clusterApply(cls, rowgrps, helper)
Reduce(max, out)
}
on.exit(stopCluster(cls))
on.exit(stopCluster(cls))
cls <- makeCluster(2)
arr1 = c(5,12,3,9,11,22,6)
findMax(cls, array) {
rowgrps <- splitIndices(length(array), length(cls))
helper <- function(group) {
return max(array[grou])
}
out <- clusterApply(cls, rowgrps, helper)
Reduce(max, out)
}
helper
findMax(cls, array) {
rowgrps <- splitIndices(length(array), length(cls))
foo <- function(group) {
return max(array[grou])
}
out <- clusterApply(cls, rowgrps, foo)
Reduce(max, out)
}
findMax(cls, array) {
rowgrps <- splitIndices(length(array), length(cls))
foo <- function(group) {
return max(array[group])
}
out <- clusterApply(cls, rowgrps, foo)
Reduce(max, out)
}
rowgrps <- splitIndices(length(array), length(cls))
foo <- function(group) {
return max(array[group])
}
foo <- function(group) max(array[group])
findMax(cls, array) {
rowgrps <- splitIndices(length(array), length(cls))
foo <- function(group) max(array[group])
out <- clusterApply(cls, rowgrps, foo)
Reduce(max, out)
}
out <- clusterApply(cls, rowgrps, foo)
findMax(cls, array) {
rowgrps <- splitIndices(length(array), length(cls))
foo <- function(group) max(array[group])
out <- clusterApply(cls, rowgrps, foo)
Reduce(max, out)
}
findMax(cls, array) {
rowgrps <- splitIndices(length(array), length(cls))
foo <- function(group) max(array[group])
#out <- clusterApply(cls, rowgrps, foo)
Reduce(max, clusterApply(cls, rowgrps, foo))
}
arr1 = c(5,12,3,9,11,22,6)
foo <- function (data) {
cls <- makeSOCKcluster(rep("localhost",2))
rowgrps <- splitIndices(length(data), length(cls))
addOne <- function(grp) {
max(data[grp])
}
out = clusterApply(cls, rowgrps, addOne)
Reduce(max, out)
}
foo(arr1)
install.packages("Rcpp")
install.packages("Rcpp")
setwd("/Users/asoong/desktop/ecs/ECS158/Parallel-Processing/hw2/Prob2_C_Solution")
library(Rcpp)
sourceCpp("Rcpp-tutorial.c")
sourceCpp("Rcpp-tutorial.cpp")
sourceCpp("/Rcpp-tutorial.cpp")
library(Rcpp)
sourceCpp("Rcpp-tutorial.cpp")
library(Rcpp)
sourceCpp("Rcpp-tutorial.cpp")
hello()
